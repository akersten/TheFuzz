# TheFuzz
This program generates asm [fuzz tests](http://en.wikipedia
.org/wiki/Fuzz_testing) for the WISC-14 ISA for ECE552.

This isn't quite "random" input, but rather an intelligent fuzz tester - it
keeps an expected state of the WISC processor and memory space while
generating the fuzz tests, so it can insert branches and generate taken/not
taken pass/failure paths. It also performs safe register and memory accesses
(it will not attempt to read from uninitialized registers or invalid memory
locations). (This may not be the exact spirit of fuzz testing,
but this decision was made in the interest of generating useful test for our
processor.)

# Features
* Specifiy specific opcodes to test
* Generate tests of any length
* Export tests to a file
* Report expected state of memory and register file at end of execution

# Usage
* Execute TheFuzz: `java io.kersten.thefuzz.Main`
* Fill in the prompts for allowed opcodes, opcode count, memory offset,
and file name

# Example output
Here are two example programs generated by the fuzz tester.

## Branch and ADDZ

      LLB R4, 0                      #; R4=0
      LLB R12, 19                    #; R12=19
      LLB R3, 17                     #; R3=17
      B GT, taken0                   #; branch on GT, take = yes
    fail1:                           #
      HLT                            #
    taken0:                          #
      B EQ, nottaken                 #; branch on EQ, take = no
      B LTE, nottaken                #; branch on LTE, take = no
      LLB R4, 45                     #; R4=45
      ADD R6, R4, R4                 #; (45+45=90); Z->0; N->0; V->0
      B EQ, nottaken                 #; branch on EQ, take = no
      ADD R1, R6, R12                #; (90+19=109); Z->0; N->0; V->0
    nottaken:                        #failure case for wrongly taken branches
      HLT                            #;

    # R0 = 0
    # R1 = 109
    # R2 = xxxx
    # R3 = 17
    # R4 = 45
    # R5 = xxxx
    # R6 = 90
    # R7 = xxxx
    # R8 = xxxx
    # R9 = xxxx
    # R10 = xxxx
    # R11 = xxxx
    # R12 = 19
    # R13 = xxxx
    # R14 = xxxx
    # R15 = xxxx

    # Z = 0 N = 0 V = 0

## All Opcodes

      SUB R10, R0, R0                #; (0-0=0); Z->1; N->0; V->0
      LLB R6, 204                    #; Load lower for sw; R6=204
      LHB R6, 114                    #; Load upper for sw; R6=29388
      SW R0, R6, -7                  #; R0=0->mem[29381]
      ADD R10, R10, R10              #; (0+0=0); Z->1; N->0; V->0
      SLL R13, R6, 1                 #; (29388<<1=-6760); Z->0
      LHB R10, 26                    #; R10=6656
      LLB R12, 42                    #; R12=42
      SRL R14, R6, 2                 #; (29388>>2=7347); Z->0
      LHB R5, 44                     #; R5=11264
      ADD R11, R5, R10               #; (11264+6656=17920); Z->0; N->0; V->0
      AND R1, R5, R5                 #; (11264&11264=11264); Z->0
      LHB R14, 114                   #; R14=29363
      LLB R11, 164                   #; Load lower for sw; R11=164
      LHB R11, 124                   #; Load upper for sw; R11=31908
      SW R0, R11, -5                 #; R0=0->mem[31903]
      LLB R6, 119                    #; R6=119
      LLB R3, 103                    #; R3=103
      AND R1, R6, R12                #; (119&42=34); Z->0
      HLT                            #;

    # R0 = 0
    # R1 = 34
    # R2 = xxxx
    # R3 = 103
    # R4 = xxxx
    # R5 = 11264
    # R6 = 119
    # R7 = xxxx
    # R8 = xxxx
    # R9 = xxxx
    # R10 = 6656
    # R11 = 31908
    # R12 = 42
    # R13 = -6760
    # R14 = 29363
    # R15 = xxxx

    # Z = 0 N = 0 V = 0

    # Valid memory addresses:
    #    mem[29381] = 0
    #    mem[31903] = 0

